ΔΗΜΗΤΡΙΟΣ ΡΑΜΜΟΣ
ΑΜ: 1115201900161

Αρχικα, η λειτουργια της copy on write:

Συνηθως, οταν καλουμε την fork εχουμε 2 διεγρασιες 1 ο γονιος και η αλλη 1 το παιδι.
Τις περισσοτερες φορες το σωμα την διεργασιας-παιδι αντικαθιστα το  "σωμα" της μεσω της
exec. Στην περιπτωση αυτη καθε διεργασια θα γινει μια δικη της σελιδα που ομως θα χουν ακριβως
τα ιδια δεδομενα. 

Αν γινει αυτο με την exec για την διεργασια-παιδι τοτε οτι αντιγραψαμε πριν απο την διεργασια-πατερας
στην διεγρασια-παιδι ουσιαστικα θα παει χαμενο και ολη η διαδικασια αντιγραφης θα ειναι επισης ασκοπη.
Δυστηχως τις περισσοτερες φορες συμβαινει αυτο.

Μια λυση για το παραπανω προβλημα, οπου εχουμε 2 διεργασιες(1-πατερα & 1-παιδι), ειναι να χουμε μια σελιδα
και για τις 2 διεργασιες μαζι, καθως στην αρχη εχουν ακριβως τα ιδια δεδομενα. 
Επομενως, και οι δυο διεργασιες τωρα θα μπορουν να διαβασουν δεδομενα απο την ιδια σελιδα.
Ομως η διαφορα γι αυτη την σελιδα θα ειναι οτι δεν θα μπορει να γραψει κανεις ουτε το παιδι ουτε ο πατερας.

Προσοχη!! Στην αρχη οταν δημιουργηθηκε αυτη η διεργασια δημιουργηθηκε για τον πατερα οπου μπορουσε να γραψει εκει
Απο την στιγμη που ο πατερας δημιουργησει τουλαχιστον ενα παιδι τοτε αυτη η σελιδα ειναι μονο για 
ΔΙΑΒΑΣΜΑ - READ ONLY και δεν μπορει να γραψει ουτε ο πατερας ουτε το παιδι ή παιδια του.
Αλλα μπορουν ολες να διαβαζουν δεδομενα απο αυτη τη σελιδα.

Οταν μια διεργασια θελει να γραψει ομως σε αυτη τη σελιδα, συνηθως το παιδι πρωτα, τοτε αυτο που θα γινεται
θα ειναι να δεσμεουμε καινουρια σελιδα για την διεργασια που θελει να γραψει να αντιγραφουμε τα δεδομενα της απο
την σελιδα read only, στην καινουρια σελιδα και επειτα να μπορει να γραψει σε αυτην.

Επομενως με την παραπανω διαδικασια κερδιζουμε σε χωρο και χρονο.

Παρακατω θα περιγραψουμε πως αυτο υλοποιηθηκε σε κομματι κωδικα σχετικα με το xv6-project-2021.
Απο το repository αυτο που υπαρχει στο github, επειτα απο το directory kernel, εχουμε τροποποιησει 5 αρχεια,
τα οποια και ειναι τα εξης:

kalloc.c
trap.c
vm.c
defs.h
riscv.h


Αρχικα η διαφορα στην υλοποιηση μας ειναι οτι τωρα θα κραταμε εναν μετρητη για καθε σελιδα που δημιουργειται και θα την
αρχικοποιουμε στη μοναδα(1). Οταν μια διεργασια που δημιουργειται δειχνει και αυτη σε μια ειδη δημιορυγηθησα σελιδα του πατερα της
τοτε αυξανουμε αυτο το  counter  κατα μια μοναδα. Οταν μια διεργασια ομως θελει να γραψει σε μια σελιδα και αναγκαζομαστε
να δημιουργησουμε νεα σελιδα για την συγκεκριμενη διεργασια τοτε μειωνεται ο μετρητης της προηγουμενης σελιδα που εδειχνε κατα μια
μοναδα(1). Αν μετα την μειωση του μετρητη ο μετρητης εχει την τιμη 0(μηδεν) τοτε αποδεσμεουμε αυτη τη σελιδα
αλλιως συνεχιζουμε κανονικα.


Σχετικα με το kalloc.c:


    Δημιουργουμε ενα struct που εχει δυο πεδια.
        
        Το ενα ειναι το spinlock lock ωστε να μην επιτρεπουμε σε αλλη συναρτηση να χειριζεται ταυτοχρονα το struct.
        Το δευτερο ειναι ο πινακας που για καθε σελιδα υπαρχει ενας μετρητης οπως αναφεραμε παραπανω για τον αριθμο των
        διεργασιων που δειχνουν σε αυτην την σελιδα.

    freerange:

        Οπως θα εξηγηθει παρκαατω η τιμη των μετρητων για τις σελιδες μειωνεται στην kfree και αν μετα την μειωση
        ειναι μηδεν ο μετρητης αποδεσμεουμε την σελιδα. Γι αυτο το λογο πριν καλεσουμε την kfree στην συναρτηση αυτη,
        αρχικοποιουμε τους μετρητες στην μοναδα ωστε να μειωθουν και επειτα να απελευθερωθουν.

    kfree:

        Η kfree οταν καλειται για μια σελιδα μειωνει τον μετρητη αν αυτος ειναι θετικος για την συγκεκριμενη σελιδα, αν
        ο μετρητης αυτος ειναι μηδεν μετα την μεθωση κατα μοναδα τοτε απελευθερωνουμαι την σελιδα, αλλιως δεν συνεχιζουμε με 
        αποδεσμευση της σελιδας καθω υπαρχει αλλη ή αλλες διεργασιες  που δειχνουν σε αυτην.

    RefPlus:

        Η συναρτηση αυτη αυξανει τον μετρητη καθε σελιδας κατα μια μοναδα, δηλαδη οτι +1 διεργασια δειχνει σε αυτη την σελιδα.
    
    kalloc:

        Στην συναρτηση αυτη το μονο που εχει προστεθει ειναι οτι καθως δημιουργειται μια καινουρια σελιδα για μια διεργασια,
        αρχικοποιειται ο μετρητης στη μοναδα.
   
        
Σχετικα με το trap.c:

 
        usertrap():
            
            Η αλλαγη εδω ειναι οτι εχει δημιουργηθει η περιπτωση που μια διεργασια δεν μπορει να γραψει σε μια σελιδα, διοτι 
            προφανως η σελιδα αυτη θα ναι σελιδα read only.
            Επομενως αν εχουμε το ερρορ = 15 τοτε, καλουμε την συναρτηση που δημιουργσαμε την CowFoldHandler που δεσμευει καινουρια 
            σελιδα για μια διεργασια.
    
        CowFoldHandler( pagetable_t, uint64):

            Κανουμε του καταλληλους ελεγχους για την δοθεισα σελιδα και βρισκουμε το pte της.
            Επειτα δημιουργουμε νεα σελιδα για την διεργασια που θελει να γραψει μεσω της kalloc.
            Στη συνεχεια αντιγραφουμε τα δεδομενα της δοθεισας σελιδας στην καινουρια σελιδα που μολις δημιουργηθεικε
            και επειτα δινουμε τα PTE.
            προφανως ο μετρητης της νεας σελιδας μεσω της kalloc θα χει αρχικοποιηθει στη μοναδα, και ο μετρητης της δοθεισας σελιδας
            θα πρεπει να μειωθει κατα μια μοναδα, που αν χειριζεται θα αποδεσμευσει την σελιδα οπως αναφερετε παραπανω.

            Για επιτυχια της συναρτησης επιστρεφουμε 0.
            Για αποτυχια της συναρτησης επιστρεφουμε -1.


Σχετικα με την vm.c:


        uvmcopy( pagetable_t, pagetable_t, uint64):

            Κανουμε την σελιδα να ειναι read only και αυξανουμε τον μετρητη της κατα μια μοναδα, δηλαδη οτι δειχνει μια διεργασια 
            παραπανω σε αυτην.            

        copyout:

            Κανουμε καποιους ελεγχους για το va0, επειτα περνουμε το pte της σελιδας.
            Επειτα, αν η σελιδα προερχεται απο περιπτω copy on write τοτε καλουμε την CowFoldHandler  και αν πετυχει συνεχιζουμε την λειτουργια
            της copyout, αλλιως την τερματιζουμε.

        mappages:
            
            Η μονη αλλαγη ειναι οτι μια σελιδα τωρα δεν αρκει να ειναι εγκυρη αλλα να ειναι και RSW( περιγραφεται παρκαατω).
        



Σχετικα με το defs.h:


        Εχουμε προσθεσει το προτυπο της συναρτησης CowFoldHandler για το trap.c
        Εχουμε προσθεσει το προτυπο της συναρτησης RefPlus για το kalloc.c
        
Σχετικα με το riscv.h:

        Εχουμε ορισει το PTE_RSW, το οποιο δηλωνει οτι μια σελιδα προκληθηκε απο copy on write.


Σε καθε αρχειο υπαρχουν σχολια τα οποια μπορειτε να δειτε για καθε τροποποιηση και λειτουργια.
Δημητριος Ραμμος

ΑΜ: 1115201900161

Αρχικα εχουμε, 3directories με ονοματα include, modules & Program.
Στο Program εχουμε τα 2 μας βασικα αρχεια μεσα το parent_process.c & child_process.c

parent_process.c:

    Στην αρχη ελεγχουμε οτι μας δινονται τα σωστα στοιχεια εισοδου απο την γραμμη εντολων
    Απο την γραμμη εντολων μας δινεται το ονομα του αρχειου οπου θα διαβαζουμε τις γραμμες του,
    ο αριθμος των διεργασιων( παιδιων) που θελουμε να δημιουργηθουν απο τον πατερα και τελος
    ποσα request θα κανει το καθε παιδι προς το πατερα( την κυρια διεργασια δηλαδη).

    Επειτα διαγραφουμε με sem_unlink τυχον σημαφορους που εχουν δημιουργηθει με το ιδιο 
    ονομα. Τα SEM_CHILD_PROCESS, SEM_CHILD2_PROCESS & SEM_PARENT_PROCESS ειναι defines
    που υπαρχουν στο inlu.h στο φακελο include.

    Επειτα, δημιουργω 3 σημαφορους με ονοματα αυτα στο defines.
    Τους σημαφορους με ονοματα sem_parent & sem_child2 τους οριζω στο 0 και τον sem_child
    στον ασσο( 1).

    Στην συνεχεια, διαβαζω τις γραμμες που χει το αρχειο μου μεσω της fgets και αποθηκευω 
    τον αριθμο αυτο στη γραμμη lines.
    Διαβαζω αυτες τις γραμμες γιατι τα παιδια πρεπει να γνωριζουν ποσες γραμμες εχει το αρχειο
    ωστε να ξερουν τι να ζητησουν.
    Επειδη ομως για να περασω τον αριθμο αυτο στο child_process.c πρεπει να ειναι σε μορφη
    string το μετατρεπω μεσω της sprintf.

    Στη συνεχεια, κανω ενα for-loop i = 1...K( Κ ειναι ο αριθμος των παιδιων που πρεπει να δημιουργηθουν)
    Αποθηκευω τα pid σε ενα πινακα ωστε να μπορω μετα να τα μαζεψει ο πατερας πριν τερματισει.
    Αν τωρα στο for-loop μας εκτελειται το παιδι τοτε αντικαθιστω το σωμα του με το αρχειο
    child_process.c οπου και αυτο εκτελειται στη συνεχεια και περναω σαν ορισμα πρωτα τον αριθμο
    των request και τον αριθμο των γραμμων.
    
    Για την Διεργασια ΠΑΤΕΡΑΣ ομως η εκτελεση συνεχιζεται και εξω απο το for-loop αλλα μονο για τον πατερα.
    Τα παιδια συνεχιζουν την εκτελεση τους sto child_process.c.
    Ο πατερας δημιουργει για ενα FILENAME ενα αρχειο κοινοχρηστης μνημης, ενα μπλοκ. 
    Επειτα εκτελει ενα while που αυτο το while θα πραγαμτοποιηθει τοσες φορες οσα τα request που θα του κανουν
    ολα τα παιδια. 
    
    Οταν το πρωτο παιδι γραψει στη μνημη θα επιτρεψει στο πατερα να διαβασει την κοινοχρηστη μνημη
    οπου και απο κει η διεργασια- ΠΑΤΕΡΑΣ θα δει ποια γραμμη θελει το παιδι του απο το αρχειο μας,
    επειτα θα την βρει θα παρει το περιεχομενο της θα το γραψει στη μνημη ωστε να μπορει το παιδι να 
    το διαβασει.

    Τελος, αφου ολα τα παιδια εχουν εκτελεσει τα request τους, το parent process θα μαζεψει τα παιδια
    αυτα μεσω την waitpid θα κλεισει τους σημαφορους και θα κανει detach την κοινοχρηστη μνμημη( δηλαδη 
    θα την κανει shmdt).


child_process.c:

    Στην αρχη ελεγχουμε οτι μας δινονται τα σωστα στοιχεια εισοδου απο τo parent_process.c
    Απο το parent_process.c μας δινεται  ποσα request θα κανει το καθε παιδι προς το πατερα( την κυρια διεργασια δηλαδη), 
    και ποσες γραμμες εχει το αρχειο.

    Επειτα, ανοιγουμε 3 σημαφορους με ονοματα αυτα στο defines(SEM_CHILD_PROCESS, SEM_CHILD2_PROCESS & SEM_PARENT_PROCESS).
    
    Ανοιγουμε ενα αρχειο κοινοχρηστης μνημης που εχει δημιουργηθει απο το parent_process.c, αν δεν εχει δημιουργηθει
    τοτε δημιουργουμε τοτε.

    Επειτα εκτελουμε ενα for-loop οσα και τα requests που πρεπει να κανει το καθε παιδι. 
    Το πρωρο παιδι κατεβαζει εναν σημαφορο απο 1 σε 0 και τωρα εκτελει μονο αυτο το critical section, 
    για request. Το παιδι διαλεγει τυχαια μια γραμμη μεταξυ των γραμμων του αρχειου και την γραφει
    στην κοινοχρηστη μνμημη ωστε να γνωριζει ο πατερας ποια γραμμη ζηταει. Επειτα οταν ο περιμενει μεχρι ο πατερας να 
    γυρισει την γραμμη, οταν την γυρισει τοτε διαβαζει απ τν κοινοχρηστη μνμημη την γραμμη που εγραψε ο πατερας
    στη κοινοχρηστη μνμημη.     

    Παραλληλα υπολογιζεται και ο χρονος καθε request και οταν τελειωσει το καθε παιδι ολα τα requests του,
    εκτυπωνεται ο μεσος ορος χρονου του για request.

    Το child_process.c κλεινει τους σημαφορους και κανει detach την κοινοχρηστη μνμημη( δηλαδη 
    θα την κανει shmdt).

Σχετικα με τα print:

    Μεταξυ της επικοινωνιας ενος parent process & child process εκτυπωνονται καταλληλα μυνηματα 
    σχετικα σε ποιο process βρισκομαστε, τι γινεται στη καθε περιπτωση και αν ειμαστε στο child process
    εκτυπωνεται το pid.

file.txt:

    Βρισκεται στο φακελο Program και ειναι το αρχειο που διαβαζουν οι διεργασιες μας και γινονται τα request
    εχει μεσα 10 γραμμες.


Makefile:

    Βρισκεται στο directory Program και μεταγλωττιζει και εκτελει το προγραμμα μας.
    Για να τρεξετε το parent_process.c τοτε τρεξτε make run στο τερμιναλ σας, και Παραλληλα θα γινει
    και η μεταγλωττιση.

Στο φακελο include υπαρχουν δυο αρχεια το inlu.h & shared_memory.h:

inlu.h:

    Eχω καποια γενικα include που μοιραζονται πολλα αρχεια και τα defines για semaphores and
    share memory.

shared_memory.h:

    Εχω καποια defines & include.



Στο φακελο modules υπαρχουν δυο αρχεια το shared_memory.c:

shared_memory.c:

    Εχω 3 συναρτησεις, οι δυο πρωτες χρησιμοποιουνται για την δημιουργια ενος αρχειου κοινοχρηστης μνημης
    Οι 2 πρωτες ειναι για την δημιουργια ή να παρουν το αρχειο κοινοχρηστης μνημης.

    attach_memory_block:   

        Kαλω την get_shared_block  ωστε να παρω βαση το filename ενα id για την κοινοχρηστη μνημη.
        Επειτα, καλω την shmat() που αφου δημιουγηθει το τμημα μοιραζομενης μνημης προσαρταται
        στο χωρο διευθυνσεων. Η shmat() μας δινει ενα δεικτη στην αρχη του τμηματος μοιραζομενης μνμημης 
        που ειναι ενα shmid.
        Αυτο γυρναμε εν τελει στο αρχειο μας parent_process.c ή child_process.c οπου την καλεσαμε. 
    
    get_shared_block:

        H shmget() χρησιμοποιειται για να δημιουργησει ή να δωσει προσβαση σε ενα αρχειο-τμημα κοινοχρηστης μνημης
        Το key ειναι ενα id σχετικα με το τμημα μοιραζομενης τμημα.

    Η τελευταια συναρτηση ειναι η
    detach_memory_block:

        καλει την shmdt() που σπαει την μνμημη αυτη απο την διεργασια που καλειεται.